/* autogenerated by Processing revision 1293 on 2023-12-01 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import processing.sound.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Deep_Dive extends PApplet {

 
 
 
 PFont font;
 globalVariables globals;
 postProcessor post;

 SoundFile ambient; 
 
 mission_control_dialogue MCD;

public void setup()
{
  /* size commented out by preprocessor */;
  frameRate(30);
  
  font = loadFont("gameFont.vlw");
  textFont(font);
  post = new postProcessor();
  post.pixelSize = 3;
  post.spread = 4;
  post.spreadCompensation = 0;
  post.COLOR_0 = 0xFF003344;
  post.COLOR_1 = 0xFF664466;
  post.COLOR_2 = 0xFFEECCAA;
  post.COLOR_3 = 0xFFFFEEDD;
  
  globals = new globalVariables();
  
  globals.game = this;
  

  
  globals.oxygenCount = 100;
  
  globals.ui = new UI(post);
  
  globals.start = true;
  globals.paused = true;
  
  ambient = new SoundFile(this, "sub_ambient.wav");
  
  MCD = new mission_control_dialogue(globals);
  
  ambient.loop();
   
  globals.scenes[0] = new S_maintenance(globals, 3, 1, 0, new PVector(160, -170));
  globals.scenes[1] = new S_window(globals, 0, 2, 1, new PVector(160, -170));
  globals.scenes[2] = new S_radio(globals, 1, 3, 2, new PVector(100, -170));
  globals.scenes[3] = new S_measurements(globals, 2, 0, 3, new PVector(160, -170));
  
  globals.scenes[4] = new S_menu(globals, -1, 2, 4, new PVector(0,-100));
  globals.scenes[5] = new S_options(globals, 4, -1, 5, new PVector(0,0));
  
  globals.scenes[6] = new S_sea(globals, 9,7,6, new PVector(150,0), requestImage("sea1.png"));
  globals.scenes[7] = new S_sea(globals, 6,8,7, new PVector(150,0), requestImage("sea2.png"));
  globals.scenes[8] = new S_sea(globals, 7,9,8, new PVector(150,0), requestImage("sea3.png"));
  globals.scenes[9] = new S_sea(globals, 8,6,9, new PVector(150,0), requestImage("sea4.png"));
  
  globals.scenes[10] = new S_diedByOxygenLoss(globals, -1,-1,10, new PVector() );
  globals.scenes[11] = new S_beatGame(globals, -1,-1, 11, new PVector() );
  
  globals.activeScene = globals.scenes[4];
  globals.activeScene.soundVolume = 1;
  
    
}

public void draw()
{
  ambient.amp(globals.ambientVolume);
  

  background(0);
  
  pushMatrix();
  scale(1.0f/post.pixelSize);
  if (!globals.paused && globals.alive)
  {
    globals.oxygenCount = max(globals.oxygenCount-globals.oxygenLostPerFrame,0);
    handleGameProgression();
    globals.framesPlaying ++;
    globals.gameProgression = globals.framesPlaying/1200.0f; //1.0 = 60s so youd want to divide by 60k
    
    if(globals.oxygenCount < 0.01f )
    {
      globals.activeScene = globals.scenes[10];
      globals.alive = false;
      globals.paused = true;
      globals.ui.switchingScene = false;
    }
  }
  MCD.update();
  globals.activeScene.renderScene();
  globals.ui.renderProcessedUI();
  
  post.render();
  popMatrix();
  
  

  globals.ui.renderUI();
  

}

public void handleGameProgression()
{
  switch(floor(globals.gameProgression))
  {
    case 0:
    globals.oxygenLostPerFrame = globals.gameProgression*.1f;
    //does the mission control talkie code go here?
    break;
    case 1:
    //1.0 : oxygen loss is .05
    globals.oxygenLostPerFrame = .1f;
    break;
    case 2:
    //2.0 : color palette fade (R) starts, mission control contact lost
    postProcessingPaletteFade((globals.gameProgression-2)/1.5f, 0xFF003344, 0xFF664466, 0xFFEECCAA, 0xFFFFEEDD,   0xFF000011, 0xFF220603, 0xFF551003, 0xFF881800);
    
    //2.5 : oxygen loss rises
    globals.oxygenLostPerFrame = max(.05f, (globals.gameProgression-2.5f)*.1f + .05f );
    break;
    case 3:
    //3.0 : oxygen loss death is no longer possible
    globals.oxygenCount = max(globals.oxygenCount, (globals.gameProgression-3)*100);
    
    if(globals.gameProgression <3.5f)
    {
      // this continues from case 2
      postProcessingPaletteFade((globals.gameProgression-2)/1.5f, 0xFF003344, 0xFF664466, 0xFFEECCAA, 0xFFFFEEDD,   0xFF000011, 0xFF220603, 0xFF551003, 0xFF881800);
      globals.oxygenLostPerFrame = max(.1f, (globals.gameProgression-2.5f)*.4f + .1f );
    }
    else if(globals.gameProgression <3.7f)
    //3.5+ : oxygen loss is .15, color palette fade (R) ends
    {
      postProcessingPaletteFade(1, 0,0,0,0,  0xFF000011, 0xFF220603, 0xFF551003, 0xFF881800);
      globals.oxygenLostPerFrame = .5f;
    }    
    else
    //3.7+ : fade to black, color palette fade (B) starts 
    {
      globals.oxygenLostPerFrame = 0;
      postProcessingPaletteFade(max(0,(globals.gameProgression-3.8f)/.2f), 0xFF000011, 0xFF220603, 0xFF551003, 0xFF881800,   0xFF112255, 0xFF554466, 0xFFEEAA77, 0xFFFFEEDD);
      globals.ui.vignettePlus = (globals.gameProgression-3.7f)/.1f;
    }
    break;
    case 4:
    //4.0 : fade to beach scene, color palette fade (B) is complete
    if(!globals.ui.switchingScene && globals.gameProgression <4.1f && globals.activeScene.thisScene != 6 && globals.activeScene.thisScene != 7 && globals.activeScene.thisScene != 8 && globals.activeScene.thisScene != 9) //aneurysm code
    {
      globals.ui.switchScene(globals.scenes[6],new PVector());
      globals.ui.log("The water is warm. The waves are calm. It's all okay.");
    }
    postProcessingPaletteFade(1, 0,0,0,0,  0xFF112255, 0xFF554466, 0xFFEEAA77, 0xFFFFEEDD);
    globals.ui.vignettePlus = max(0,1-(globals.gameProgression-4.0f)/.2f);
    //4.3 : cut to black, you diesd
    if(globals.activeScene != globals.scenes[11] && globals.gameProgression>4.5f)
    {
      globals.activeScene = globals.scenes[11];
      globals.ui.nextScene = globals.scenes[11];
      globals.ui.framesSwitchingScene = globals.ui.switchSceneTimeFrame/2;
      globals.activeScene.onSwitchScene();
    }
    //TODO: death
    //actually thats S_beatGame's problem now
    break;
    
  }
}

public void postProcessingPaletteFade(float lerp, int COLOR_10, int COLOR_11, int COLOR_12, int COLOR_13, int COLOR_00, int COLOR_01, int COLOR_02, int COLOR_03)
{
  post.COLOR_0 = lerpColor(COLOR_10,COLOR_00,lerp);
  post.COLOR_1 = lerpColor(COLOR_11,COLOR_01,lerp);
  post.COLOR_2 = lerpColor(COLOR_12,COLOR_02,lerp);
  post.COLOR_3 = lerpColor(COLOR_13,COLOR_03,lerp);
}

public void mousePressed()
{
  if(!globals.ui.switchingScene)
  {
    globals.activeScene.updateScene(mouseAction.PRESSED);
    globals.ui.mouseAction(mouseAction.PRESSED);
  }
}

public void mouseReleased()
{
  if(!globals.ui.switchingScene)
  {
    globals.activeScene.updateScene(mouseAction.RELEASED);  
    globals.ui.mouseAction(mouseAction.RELEASED);
  }
}

public void mouseWheel(MouseEvent event)
{
 globals.ui.mouseAction(event.getCount());
}
class Monster
{
  PVector position;
  PVector scale;
  PImage sprite;
  int spot;
  boolean left;
  int startFrame;
  globalVariables globals;
  
  Monster(PVector scale, int spot, PImage sprite, globalVariables globals)
  {
    this.scale = scale;
    this.spot = spot;
    this.sprite = sprite;
    this.globals = globals;
    if (spot % 2 == 1)
    left = true;
    
    switch(spot)
    {
      default:
      break;
      
      case 1:
      this.position = new PVector(600,650);
      break;
      
      case 2:
      this.position = new PVector(1050,650);
      break;
      
      case 3:
      this.position = new PVector(600,250);
      break;
      
      case 4:
      this.position = new PVector(1050,650);
      break;
      
      case 5:
      this.position = new PVector(600,650);
      break;
    }
    int startFrame = globals.framesPlaying;
  }
  
  public void render(PVector _position)
  {
    _position = new PVector();
    if (globals.framesPlaying > startFrame + 15)
    {
      if (left)
      {
        pushMatrix();
        scale(-1, 1);
        translate( -position.x - _position.x, position.y + _position.y);
        image(sprite, 0, 0, scale.x, scale.y);
        popMatrix();
        position.x -= 10;
      }
      else
      {
        image(sprite, position.x + _position.x, position.y + _position.y, scale.x, scale.y);
        position.x += 10;
      }
    }
    
    
  }
  
}
class S_beatGame extends scene
{
  SoundFile subExplode;
  int frames = 0;
  PImage submarine;
  PImage submarineDiesd;
  S_beatGame(globalVariables globals, int left, int right, int current, PVector position)
  {
    super(globals, left, right, current, position, true);
    subExplode = new SoundFile(globals.game, "sub-explode.wav");
    submarine = requestImage("submarine.png");
    submarineDiesd = requestImage("submarineDiesd.png");
  }
  
  public void renderScene()
  {
    fill(255);
    image(submarine, 0, 0, width, height);
    if(frames == 40)
    {
      subExplode.play();
    }
    if(frames >= 60)
    {
      tint((frames-20)*22.5f);
      image(submarineDiesd, 0, 0, width, height);
      noTint();
    }
    frames++;
    textSize(100);
    textAlign(CENTER);
    if(frames >= 80)
    {
    text("YOU DIED", width/2, height/2);
    textSize(60);
    text("Measurements made: "+globals.tasks, width/2, height/2+100);
    }
    textAlign(CORNER);
  }
}
class S_diedByOxygenLoss extends scene
{
  int frames = 0;
  S_diedByOxygenLoss(globalVariables globals, int left, int right, int current, PVector position)
  {
    super(globals, left, right, current, position, true);
  }
  
  public void renderScene()
  {
    globals.oxygenCount = 100;
    globals.ui.switchingScene = false;
    frames++;
    background(0);
    fill(min(255,frames*5));
    textSize(100);
    textAlign(CENTER);
    text("YOU DIED", width/2, height/2);
    textSize(60);
    text("Measurements made: "+globals.tasks, width/2, height/2+100);
    text("Time survived: "+(globals.framesPlaying/30)+" seconds", width/2, height/2+150);
    textAlign(CORNER);
  }
}
class S_maintenance extends scene
{
  ArrayList<pressureLever> levers;
  int pressureValue = 0;
  PImage background;
  PImage background_t;
  int puzzle[] = new int[9];

  int puzzle1[] = {13, 6, 9, 3, 10, -3, 7, -4, 24};
  int puzzle2[] = {3, -6, 5, 1, 7, -2, 8, 10, 30};
  int puzzle3[] = {1, 3, 5, 7, 9, -2, -4, -6, 16};
  int puzzle4[] = {4, 6, 2, -3, 9, -1, 7, -4, 12};
  int puzzle5[] = {6, 1, -9, -3, 2, 8, 3, -4, 5};


  PImage wheel;
  PImage arrowCircle;
  float arrowCircleTint = 0;
  float targetRotationSpeed = 0.03f;
  float oxygenBarRotationInRadians = 0;
  int wheeloffx = 260;
  int wheeloffy = 550; //coordinates of the oxygen wheel
  int wheelboxoff = 0; //placement of the oxygen wheel mouse target box
  int wheelSize = 200;
  float mouseRotationInRadians = 0;
  float mouseRotationInRadiansP = 0;
  boolean mouseHeldOnWheel = false;
  float wheelRotationInRadians = 0;
  float mouseVel[] = new float[60];
  int mouseVelSel = 0;
  int currentPuzzle;

  SoundFile valveTurning;

  S_maintenance(globalVariables globals, int left, int right, int current, PVector position)
  {
    super(globals, left, right, current, position, false);

    levers = new ArrayList<pressureLever>();

    currentPuzzle = floor(random(1, 6));

    switch(currentPuzzle)
    {
    default:
      break;
      case (1):
      for (int i = 0; i < 9; i++)
      {
        puzzle[i] = puzzle1[i];
      }
      break;
      case (2):
      for (int i = 0; i < 9; i++)
      {
        puzzle[i] = puzzle2[i];
      }
      break;
      case (3):
      for (int i = 0; i < 9; i++)
      {
        puzzle[i] = puzzle3[i];
      }
      break;
      case (4):
      for (int i = 0; i < 9; i++)
      {
        puzzle[i] = puzzle4[i];
      }
      break;
      case (5):
      for (int i = 0; i < 9; i++)
      {
        puzzle[i] = puzzle5[i];
      }
      break;
    }
    globals.puzzleSet = true;
    int currentValue = 0;
    for (int i = 0; i < 4; i++)
    {
      levers.add(new pressureLever("toplever" + (i+1), new PVector(30, 20), new PVector((580 + 120 * i), 470), puzzle[currentValue]));
      currentValue++;
    }
    for (int i = 0; i < 4; i++)
    {
      levers.add(new pressureLever("toplever" + (i+1), new PVector(30, 20), new PVector((580 + 120 * i), 710), puzzle[currentValue]));
      currentValue++;
    }
    background = requestImage("maintenance.png");
    background_t = requestImage("maintenance_t.png");

    wheel = requestImage("maintenanceWheel.png");
    arrowCircle = requestImage("arrowsCircle.png");

    valveTurning = new SoundFile(globals.game, "valve_turning.wav");
  }

  public void renderScene()
  {
    image(background, position.x, position.y, 1200, 1200);
    if (globals.radio)
    {

      if (!globals.p_Start)
      {
        for (pressureLever lever : levers)
        {
          lever.setOff();
        }
        currentPuzzle = floor(random(1, 6));
        if (!globals.puzzleSet)
        {
          switch(currentPuzzle)
          {
          default:
            break;
            case (1):
            for (int i = 0; i < 9; i++)
            {
              puzzle[i] = puzzle1[i];
            }
            break;
            case (2):
            for (int i = 0; i < 9; i++)
            {
              puzzle[i] = puzzle2[i];
            }
            break;
            case (3):
            for (int i = 0; i < 9; i++)
            {
              puzzle[i] = puzzle3[i];
            }
            break;
            case (4):
            for (int i = 0; i < 9; i++)
            {
              puzzle[i] = puzzle4[i];
            }
            break;
            case (5):
            for (int i = 0; i < 9; i++)
            {
              puzzle[i] = puzzle5[i];
            }
            break;
          }
        }
        globals.puzzleSet = true;
      }
    }

    fill(120);
    rectMode(CORNER);
    rect(215 + position.x, 830 + position.y, 75, -120 * (globals.oxygenCount * 0.01f));


    rect(450 + position.x, 830 + position.y, 40, -((pressureValue + 20) * 5));

    image(background_t, position.x, position.y, 1200, 1200);

    pressureValue = 0;
    for (pressureLever lever : levers)
    {
      lever.render(new PVector(mouseX, mouseY), position);
      if (lever.on)
      {
        pressureValue += lever.pressureValue;
      }
    }
    //textSize(40);
    fill(0);

    triangle(450 + position.x, position.y + 830 - (5 * (puzzle[8] + 20)), position.x + 420, position.y + 830 - (5 * (puzzle[8] + 20))+20, position.x + 420, position.y + 830 - (5 * (puzzle[8] + 20))-20);

    stroke(0);
    strokeWeight(2);
    if (pressureValue > puzzle[8] -2 && pressureValue < puzzle[8] + 2  && !globals.p_Done)
    {
      globals.p_Done = true;
      globals.ui.log("Pressure resolved");
    }


    mouseVelSel++;
    mouseVelSel%=mouseVel.length;
    mouseVel[mouseVelSel] = 0;

    mouseRotationInRadiansP = mouseRotationInRadians;
    PVector mousePos = new PVector(mouseX, mouseY);
    mousePos.sub(new PVector(wheeloffx+position.x, wheeloffy+position.y));
    mouseRotationInRadians = PVector.angleBetween(mousePos, new PVector(1, 0));
    if (PVector.angleBetween(mousePos, new PVector(0, 1)) > HALF_PI)
      mouseRotationInRadians = -mouseRotationInRadians;

    if (mouseHeldOnWheel)
    {
      mouseVel[mouseVelSel] = mathExtras.radianDifference(mouseRotationInRadians, mouseRotationInRadiansP);
      wheelRotationInRadians += mouseVel[mouseVelSel];
    }
    oxygenWheelUpdate();
  }

  public void oxygenWheelUpdate()
  {
    oxygenBarRotationInRadians += targetRotationSpeed;
    PVector mousePos = new PVector(mouseX, mouseY);
    mousePos.sub(wheeloffx+position.x, wheeloffy+position.y);
    mousePos.rotate(-oxygenBarRotationInRadians);
    mousePos.sub(wheelboxoff, 0);

    pushMatrix();
    //the mouse controlled code
    translate(wheeloffx+position.x, wheeloffy+position.y);
    rotate(wheelRotationInRadians);
    rectMode(CENTER);
    image(wheel, wheelSize*-.5f, wheelSize*-.5f, wheelSize, wheelSize);
    popMatrix();

    pushMatrix();
    //the guides for rotating
    translate(wheeloffx+position.x, wheeloffy+position.y);
    rotate(oxygenBarRotationInRadians);
    if (abs(mousePos.x) < 125 && abs(mousePos.y) < 125)
      arrowCircleTint += 3.5f;
    arrowCircleTint *= .98f;
    tint(255, arrowCircleTint);
    image(arrowCircle, -125, -125, 250, 250);
    noTint();
    popMatrix();

    //fill(255);
    //textSize(50);
    //text(mouseRotationInRadians - mouseRotationInRadiansP, 1000, 50);

    float avgVel = getAvgVel();
    //text(avgVel, 1000, 100);

    float scoreplus = max(0, 1-40*abs(avgVel-targetRotationSpeed));
    globals.oxygenCount = min(100, globals.oxygenCount+scoreplus*.2f);

    if (scoreplus > 0 && !valveTurning.isPlaying())
      valveTurning.loop();

    if (valveTurning.isPlaying())
      valveTurning.amp(scoreplus);

    if (scoreplus <= 0)
      valveTurning.stop();
    //text(globals.oxygenCount, wheeloffx+position.x, wheeloffy+position.y+100);
  }

  public float getAvgVel()
  {
    float d = 0;
    for (int a = 0; a<mouseVel.length; a++)
    {
      d+=mouseVel[a];
    }
    return d/mouseVel.length;
  }

  public void updateScene(mouseAction action)
  {
    if (!globals.paused)
    {
      switch(action)
      {
      default:
        break;

      case RELEASED:
        mouseHeldOnWheel = false;
        if (!globals.p_Done && globals.radio)
          for (pressureLever lever : levers)
          {
            lever.onLeftClickReleased(position);
            if (!globals.p_Start)
            {
              globals.p_Start = true;
            }
          }

        break;

      case PRESSED:
        PVector mousePos = new PVector(mouseX, mouseY);
        mousePos.sub(new PVector(wheeloffx+position.x, wheeloffy+position.y));
        mouseHeldOnWheel = mousePos.magSq() < wheelSize*wheelSize*.25f;
        break;
      }
    }
  }
}
class S_measurements extends scene
{
  PImage background;
  int waterType;
  clickableObject thermometer;
  clickableObject tap;
  boolean tapped;
  PImage bottleFull;
  PImage bottleEmpty;
  PImage[] measureSticks;
  PImage sheet;
  clickableObject[] buttons;
  int currentID;
  boolean showStick;

  SoundFile therm_tap;

  S_measurements(globalVariables globals, int left, int right, int current, PVector position)
  {
    super(globals, left, right, current, position, false);
    background = requestImage("measurements.png");

    thermometer = new imageButton("thermometer", new PVector(90, 170), new PVector(900, 513), requestImage("thermometer.png"));

    tap = new clickableObject("tap", new PVector(30, 45), new PVector(575, 510));
    buttons = new clickableObject[5];
    measureSticks = new PImage[5];
    bottleFull = requestImage("bottle_full.png");
    bottleEmpty = requestImage("bottle_empty.png");
    sheet = requestImage("sheet.png");

    for (int i = 0; i < 5; i++)
    {
      buttons[i] = new clickableObject(String.valueOf(i), new PVector(30, 30), new PVector(900, 290 + i* 85));
      measureSticks[i] = requestImage("stick"+i+".png");
    }

    currentID = floor(random(0, 5));

    therm_tap = new SoundFile(globals.game, "tapping_thermometer.wav");
  }

  public void updateScene(mouseAction action)
  {
    if (!globals.paused)
    {
      switch(action)
      {
      default:
        break;

      case RELEASED:
        if (thermometer.checkClickIntersection(position) && !globals.t_Done && globals.radio && !showStick)
        {
          globals.ui.log("Temperature logged");
          therm_tap.play();
          globals.t_Done = true;
        }
        if (!globals.w_Done && globals.radio)
        {
          if (tap.checkClickIntersection(position))
          {
            showStick = true;
            tapped = true;
            globals.ui.log("Took water sample");
          }
          for (clickableObject button : buttons)
          {
            if (button.checkClickIntersection(position) && showStick)
            {
              if (button.name.equals(String.valueOf(currentID)))
              {
                globals.ui.log("That seemed to be the correct answer, logging results");
                globals.w_Done = true;
                currentID = floor(random(0, 5));
                tapped = false;
                showStick = false;
              } else
              {
                globals.ui.log("That doesn't seem right");
              }
            }
          }
        }


        break;
      }
    }
  }

  public void renderScene()
  {
    therm_tap.amp(globals.sfxVolume);

    image(background, position.x, position.y, 1200, 1200);

    rectMode(CENTER);
    fill(255, 0, 0);
    rect(thermometer.position.x + position.x, thermometer.position.y+ position.y +40, 20, 150);
    thermometer.render(position);
    //rect(thermometer.position.x + position.x,thermometer.position.y+ position.y,thermometer.shapeD.x,thermometer.shapeD.y);
    //rect(tap.position.x+ position.x, tap.position.y + position.y, tap.shapeD.x,tap.shapeD.y);

    if (tapped)
      image(bottleFull, 456 + position.x, 599 + position.y, 220, 250);
    else
      image(bottleEmpty, 456+position.x, 599+position.y, 220, 250);
    if (showStick)
    {
      image(measureSticks[currentID], 160+position.x, 220+position.y, 180, 550);
      image(sheet, 500 + position.x, 235 + position.y, 450, 450);
      for (clickableObject button : buttons)
      {
        rect(button.position.x + position.x, button.position.y + position.y, button.shapeD.x, button.shapeD.y);
      }
    }
  }
}
class S_menu extends scene
{
  PImage background;
  clickableObject startGame;
  clickableObject exit;
  clickableObject options;

  S_menu(globalVariables globals, int left, int right, int current, PVector position)
  {
    super(globals, left, right, current, position, true);
    background = loadImage("main_menu.png");
    startGame = new clickableObject("startGame", new PVector(40, 40), new PVector(350, 720));
    exit = new clickableObject("exit", new PVector(40, 40), new PVector(610, 720));
    options = new clickableObject("options", new PVector(40, 40), new PVector(870, 720));
    
  }

  public void renderScene()
  {
    image(background, position.x, position.y, 1200, 1200);
    textSize(210);
    textAlign(CENTER);
    fill(0);
    text("DEEP DIVE", 610, 310);
    fill(255);
    text("DEEP DIVE", 600, 300);
    textAlign(CORNER);
  }
  public void updateScene(mouseAction action)
  {
    switch(action)
    {
    default:
      break;

    case RELEASED:
      if (options.checkClickIntersection(position))
      {
        globals.ui.options();
        break;
      }
      if (exit.checkClickIntersection(position))
        exit();
      if (!startGame.checkClickIntersection(position))
        break;
      globals.ui.switchScene(globals.scenes[2], new PVector(0,100));
      globals.paused = false;
      globals.alive = true;

      break;
    }
  }
}
class S_options extends scene
{
  PImage background;
  float ambientPos = 1000;
  float sfxPos = 1000;
  clickableObject ambientNode;
  clickableObject sfxNode;
  imageButton back;
  boolean ambientClicked;
  boolean sfxClicked;
  
  S_options(globalVariables globals, int leftScene, int rightScene, int current, PVector position)
  {
    super(globals, leftScene, rightScene, current, position, true);
    background = requestImage("options.png");
    ambientNode = new clickableObject("ambientNode", new PVector(25,25), new PVector(1000, 320));
    sfxNode = new clickableObject("sfxNode", new PVector(25,25), new PVector(1000, 520));
    back = new imageButton("back", new PVector(40, 40), new PVector(50, 50), requestImage("arrowLeft.png"));
  }
  
  public void renderScene()
  {

    image(background, position.x, position.y, 1200, 1200);
    
    
    
    if (ambientClicked)
    {
      if (mouseX < 200)
      {
      ambientPos = 200;
      ambientNode.position.x = 200;
      }
      else if (mouseX > 1000)
      {
      ambientPos = 1000;
      ambientNode.position.x = 1000;
      }
      else
      {
      ambientPos = mouseX;
      ambientNode.position.x = mouseX;
      }
    }
    
    if (sfxClicked)
    {
      if (mouseX < 200)
      {
      sfxPos = 200;
      sfxNode.position.x = 200;
      }
      else if (mouseX > 1000)
      {
      sfxPos = 1000;
      sfxNode.position.x = 1000;
      }
      else
      {
      sfxPos = mouseX;
      sfxNode.position.x = mouseX;
      }
    }
    
    globals.ambientVolume = (ambientPos - 200) / 800;
    globals.sfxVolume = (sfxPos - 200) / 800;
    
    back.render(new PVector());
    
    rectMode(CORNER);
    fill(128);
    rect(200, 300, 800, 40);
    rect(200, 500, 800, 40);
    fill(80);
    ellipseMode(CENTER);
    ellipse(ambientPos, 320, 50, 50);
    ellipse(sfxPos, 520, 50, 50);
    fill(255);
    textSize(80);
    text("Ambient Volume", 300, 250);
    text("SFX Volume", 400, 450);
  }
  
  public void updateScene(mouseAction action)
  {
    switch(action)
    {
      default:
      break;
      
      case RELEASED:
      //globals.ui.switchScene(globals.scenes[leftScene], new PVector());
      ambientClicked = false;
      sfxClicked = false;
      if (back.checkClickIntersection(new PVector()))
      {
      globals.ui.switchScene(globals.scenes[leftScene], new PVector());
      globals.options = false;
      }
      break;
      
      case PRESSED:
      if (ambientNode.checkClickIntersection(position))
      {
        ambientClicked = true;
      }
      
      if (sfxNode.checkClickIntersection(position))
      {
        sfxClicked = true;
      }
    }
  }
  
}
class S_radio extends scene
{
  PImage background;
  imageButton radio;

  S_radio(globalVariables globals, int left, int right, int current, PVector position)
  {
    super(globals, left, right, current, position, false);
    background = requestImage("radio.png");
    radio = new imageButton("radio", new PVector(80, 140), new PVector(1010, 610), requestImage("radio_icon.png"));
  }

  public void renderScene()
  {
    image(background, position.x, position.y, 1200, 1200);
    radio.render(position);
  }

  public void updateScene(mouseAction action)
  {
    
  }
}
class S_sea extends scene
{
  PImage background; 
  S_sea(globalVariables globals, int left, int right, int current, PVector position, PImage backgr)
  {
    super(globals, left, right, current, position, false);
    background = backgr;
  }
  
  public void renderScene()
  {
    image(background,position.x, position.y, 1200,900);
  }
}
class S_window extends scene
{
  clickableObject typeWriter;
  public boolean taskDone;
  PImage background;
  PImage bigFish;
  SoundFile typing;

  float fishX;
  boolean fishSpawn;
  float fishTime;
  float fishSpeed = 0.5f;


  S_window(globalVariables globals, int left, int right, int current, PVector position)
  {
    super(globals, left, right, current, position, false);
    background = requestImage("window.png");
    bigFish = requestImage("big_fish.png");
    typing = new SoundFile(globals.game, "typewriter.wav");


    fishX = 550;
    typeWriter = new imageButton("typewriter", new PVector(75, 60), new PVector(680, 540), loadImage("typeWriter.png"));
  }

  public void renderScene()
  {
    typing.amp(globals.sfxVolume);

    fill(0, 0, 255);
    rect(2000, 2000, 0, 0);

    if (globals.gameProgression > 2 && fishSpawn)
    {
      
      image(bigFish, fishX + position.x, 190 + position.y, 5000, 600);
      if (millis() > fishTime + 1000 && !globals.paused)
      {
        fishX -= fishSpeed;
        if (fishSpeed < 15)
          fishSpeed += 0.15f;
      }
    }
    image(background, position.x, position.y, 1200, 1200);
    typeWriter.render(position);
  }

  public void updateScene(mouseAction action)
  {
    {
      if (action == mouseAction.RELEASED && globals.p_Done && globals.t_Done && globals.w_Done && typeWriter.checkClickIntersection(position) && !globals.paused && !globals.logged)
      {
        globals.ui.log("all tasks done, results logged");
        typing.play();
        globals.tasks++;
        globals.start = false;
        globals.radio = true;
        globals.p_Done = false;
        globals.p_Start = false;
        globals.t_Done = false;
        globals.w_Done = false;
        globals.puzzleSet = false;
        
        
      }
    }
  }
  
  public void onSwitchScene()
  {
    if (globals.gameProgression > 2 && !fishSpawn)
    {
      fishTime = millis();
      fishSpawn = true;
    }
  }
  
}
class UI
{
  imageButton leftArrow;
  imageButton rightArrow;
  imageButton pauseButton;
  
  clickableObject resume;
  clickableObject options;
  clickableObject exit;
  
  scrollBox logBox;
  int logs;
  ArrayList<log> logList;
  postProcessor post;
  PImage vignette0;
  PImage vignette1;
  float vignetteAmount = 0;
  FloatList logBoxAddHeight = new FloatList();

  float vignettePlus = 0;

  PImage pauseMenu;
  
  ArrayList<Monster> monsters;
  

  UI(postProcessor _post)
  {
    leftArrow = new imageButton("leftArrow", new PVector(40, 40), new PVector(350, 805), requestImage("arrowLeft.png"));
    rightArrow = new imageButton("rightArrow", new PVector(40, 40), new PVector(1150, 805), requestImage("arrowRight.png"));
    pauseButton = new imageButton("pauseButton", new PVector(40, 40), new PVector(1150, 50), requestImage("pause_button.png"));
    
    resume = new clickableObject("resume", new PVector(250, 50), new PVector(765, 340));
    options = new clickableObject("options", new PVector(250, 50), new PVector(765, 505));
    exit = new clickableObject("exit", new PVector(250, 50), new PVector(765, 685));
    
    logBox = new scrollBox("logBox", new PVector(150, 450), new PVector(150, 450), 50, 0);
    logList = new ArrayList<log>();
    post = _post;
    vignette0 = requestImage("vignette0.png");
    vignette1 = requestImage("vignette1.png");
    pauseMenu = requestImage("pause.png");
    
    monsters = new ArrayList<Monster>();
  }



  public void renderUI()
  {
    if (!globals.activeScene.fullScreenScene)
    {
      if (!globals.paused)
      {
      tint(post.COLOR_2);
      leftArrow.render(new PVector(0, 0));
      rightArrow.render(new PVector(0, 0));
      pauseButton.render(new PVector());
      noTint();
      }
      
      
      
      for (int i = 0; i<logBoxAddHeight.size(); i++)
      {
        float GET = logBoxAddHeight.get(i)*.1f;
        logBoxAddHeight.sub(i, GET);
        logBox.scrollHeight += GET;
        if (GET>.01f) continue;
        logBoxAddHeight.remove(i);
        i--;
      }
      logBox.rescaleContentLength((logs-7) * 120);

      logBox.render(new PVector(mouseX, mouseY), post.COLOR_0, post.COLOR_1, post.COLOR_2, post.COLOR_3);
      for (log log : logList)
      {
        log.position.y = log.originalHeight - logBox.scrollHeight;
        log.render(post.COLOR_0, post.COLOR_1, post.COLOR_2, post.COLOR_3);
      }
      
      
      if (globals.paused)
      {
        tint(post.COLOR_2);
        rectMode(CORNER);
        image(pauseMenu, 300, 0, 900, 900);
        noTint();
      }
    }
  }

  public void renderProcessedUI()
  {
    
    for (Monster monster : monsters)
      {
        monster.render(globals.activeScene.position);
      }
    
    if(globals.alive)vignetteAmount = 1.0f-globals.oxygenCount*0.01f; else vignetteAmount = 0;
    vignetteAmount += vignettePlus;
    if (switchingScene)switchSceneUpdate();

    tint(255, .5f*vignetteAmount*255);
    if (!globals.activeScene.fullScreenScene) image(vignette0, 300, 0, 900, 900);
    else image(vignette0, 0, 0, 1200, 900);
    tint(255, vignetteAmount*255);
    if (!globals.activeScene.fullScreenScene) image(vignette1, 300, 0, 900, 900);
    else image(vignette1, 0, 0, 1200, 900);
    fill(0, pow(vignetteAmount, 6)*255);
    rectMode(CORNER);
    rect(0, 0, width, height);
    noTint();
    
    
  }

  public void log(String text)
  {
    logList.add(new log(text, new PVector(140, 80 + (logs * 120))));
    logs++;
    if (logs > 7)
    {
      logBox.rescaleContentLength((logs-7) * 120);
      logBoxAddHeight.append(120);
    }
  }

  public void mouseAction(mouseAction action)
  {
    if (action == mouseAction.RELEASED)
    {
      if (!globals.paused)
      {
      if (leftArrow.checkClickIntersection(new PVector(0, 0)))
        leftScene();
      if (rightArrow.checkClickIntersection(new PVector(0, 0)))
        rightScene();
      if (pauseButton.checkClickIntersection(new PVector(0, 0)))
        globals.paused = true;
      logBox.onLeftClickRelease();
      }
      else if (!globals.options && !globals.activeScene.fullScreenScene)
      {
        if (resume.checkClickIntersection(new PVector()))
        globals.paused = false;
        if (options.checkClickIntersection(new PVector()))
        options();
        if (exit.checkClickIntersection(new PVector()))
        exit();
      }
    }
    if (action == mouseAction.PRESSED)
    {
      logBox.onLeftClick(new PVector(mouseX, mouseY));
    }
  }

  public void mouseAction(float e)
  {
    logBox.onScroll(e, new PVector(mouseX, mouseY));
  }

  boolean switchingScene = false;
  int framesSwitchingScene;
  int switchSceneTimeFrame = 40;
  PVector sceneMoveDirection;
  scene nextScene;

  public void switchScene(scene next, PVector direction)
  {
    sceneMoveDirection = direction;
    nextScene = next;
    framesSwitchingScene = -switchSceneTimeFrame/2;
    switchingScene = true;
  }

  public void switchSceneUpdate()
  {
    framesSwitchingScene++;
    if (framesSwitchingScene == 0) 
    {
      globals.activeScene = nextScene;
     globals.activeScene.onSwitchScene(); 
    }
    switchingScene = framesSwitchingScene < switchSceneTimeFrame*.5f;
    float d = framesSwitchingScene/(switchSceneTimeFrame*.5f);
    vignetteAmount += 1.0f-abs(d);

    if (framesSwitchingScene<0)
      globals.activeScene.position = PVector.add(globals.activeScene.startPosition, new PVector((-d*d-2*d-1)*sceneMoveDirection.x, (-d*d-2*d-1)*sceneMoveDirection.y));
    else
      globals.activeScene.position = PVector.add(globals.activeScene.startPosition, new PVector((d*d-2*d+1)*sceneMoveDirection.x, (d*d-2*d+1)*sceneMoveDirection.y));
  }


  public void leftScene()
  {
    switchScene(globals.scenes[globals.activeScene.leftScene], new PVector(-100, 0));
  }

  public void rightScene()
  {
    switchScene(globals.scenes[globals.activeScene.rightScene], new PVector(100, 0));
  }

  public void options()
  {
    globals.scenes[5].leftScene = globals.activeScene.thisScene;
    switchScene(globals.scenes[5], new PVector());
    globals.options = true;
  }
}
class clickableObject
{
  String name;
  PVector shape;
  PVector shapeD;
  PVector position;
  
  clickableObject(String _name, PVector _shape, PVector _position)
  {
    if(_shape.x < 1 || _shape.y < 1)
    println("WARNING - button smaller than 1 created!");
    name = _name;
    shape = _shape;
    shapeD = PVector.mult(_shape,2);
    position = _position;
  }
  
  public void render(PVector _position)
  {
    //rectMode(CENTER);
    // rect(position.x + _position.x, position.y + _position.y, shapeD.x, shapeD.y);
  }
  
  public void onLeftClick()
  {
  }
  
  public boolean checkClickIntersection(PVector offset)
  {
    return checkIntersection(new PVector(mouseX, mouseY), offset);
  }
  
  public boolean checkIntersection(PVector clickPosition, PVector offset)
  {
    PVector relativePos = PVector.sub(PVector.add(offset, position),clickPosition);
    if( abs(relativePos.x) > shape.x )
    return false;
    return abs(relativePos.y) < shape.y;
  }
}
class globalVariables
{
  
  Deep_Dive game;
  
  boolean paused;
  boolean options;
  boolean start;
  boolean alive;
  
  int tasks = 0;
  
  boolean puzzleSet;
  boolean p_Done;
  boolean t_Done;
  boolean w_Done;
  
  boolean logged;
  boolean radio=true;
  
  boolean p_Start;
  //float temp;
  
  float ambientVolume = 1;
  float sfxVolume = 1;
  
  float oxygenCount;
  float oxygenLostPerFrame = .05f;
  
  
  scene activeScene;
  scene scenes[] = new scene[12];
  
  UI ui;
  
  int framesPlaying = 0;
  float gameProgression = 0;
  //1.0 : oxygen loss is .05
  //2.0 : color palette fade (R) starts, mission control contact lost
  //2.5 : oxygen loss rises
  //3.0 : oxygen loss death is no longer possible
  //3.5 : oxygen loss is .15, color palette fade (R) ends
  //3.7 : fade to black, color palette fade (B) starts 
  //4.0 : fade to beach scene, color palette fade (B) is complete
  //4.3 : cut to black, you diesd
  
}
class imageButton extends clickableObject
{
  PImage icon;
  imageButton(String _name, PVector _shape, PVector _position, PImage _icon)
  {
    super(_name, _shape, _position);
    icon = _icon;
  }
  
  public void render(PVector offset)
  {
    image(icon, position.x - shape.x + offset.x, position.y - shape.y + offset.y, shapeD.x, shapeD.y);
  }
  
}
class log
{
  String text;
  PVector shape;
  PVector position;
  float originalHeight;
  
  log(String text, PVector position)
  {
    this.text = text;
    this.shape = new PVector(250,100);
    this.position = position;
    originalHeight = position.y;
  }
  
  public void render(int COLOR_0, int COLOR_1, int COLOR_2, int COLOR_3)
  {
    rectMode(CENTER);
    stroke(COLOR_0);
    fill(COLOR_2);
    rect(position.x, position.y, shape.x, shape.y);
    
    fill(COLOR_0);
    textSize(20);
    text(text, position.x, position.y, shape.x - 25, shape.y - 10);
  }
  
}
static class mathExtras
{
  public static float radianDifference(float a, float b)
  {
    return (PI - abs(abs( (a%TAU) - (b%TAU) ) - PI)) * sign(a-b);
  }
  
  public static float sign(float a)
  {
    return a < 0 ? -1 : 1;
  }
}
class mission_control_dialogue
{
  globalVariables globals;
  boolean audioPaused;
  missionControlMessage dialogue[] =
    {
    null,
    new missionControlMessage("So, the goal of today's mission is to analyze water samples", 120, null),
    new missionControlMessage("and take temperature measurements at different depths.", 230, null),
    new missionControlMessage("Each time after you are done with that, document the results.", 320, null),
    new missionControlMessage("But this is not all, we had to rent an older submarine this time", 420, null),
    new missionControlMessage("so you will have to look after the life support systems.", 520, null),
    new missionControlMessage("That implies pumping the oxygen and leveling the pressure.", 600, null),
    new missionControlMessage("If an emergency with life support occurs, we will see it up here", 680, null),
    new missionControlMessage("and pull you back up.", 760, null),
    new missionControlMessage("End of the briefing and good luck out there.", 800, null),

    //this below message makes sure nothing gets spammed - make 100% sure its the last one (and is there)!!!
    new missionControlMessage("seriously? youve been playing for 27 months. the game is not THAT fun", 0x7FFFFFFF, null)
  };
  int currentDialogueIndex = 0;

  mission_control_dialogue(globalVariables _globals)
  {
    globals = _globals;
    dialogue[0] = new missionControlMessage("Okay, let's get to work", 60, new SoundFile(globals.game, "briefing.wav"));
  }

  public void update()
  {
    dialogue[0].audio.amp(globals.sfxVolume);
    
    if (globals.paused && dialogue[0].audio.isPlaying())
    {
      println("buh");
      dialogue[0].audio.pause();
      audioPaused = true;
    }


    if (!globals.paused)
    {
      
      if (audioPaused)
      {
        dialogue[0].audio.play();
        audioPaused = false;
      }
      
      if (globals.framesPlaying <= dialogue[currentDialogueIndex].frameToPlayAt)
        return;




      
      globals.ui.log(dialogue[currentDialogueIndex].text);
      if (dialogue[currentDialogueIndex].audio != null)
        dialogue[currentDialogueIndex].audio.play();
      if (currentDialogueIndex < dialogue.length-1)
        currentDialogueIndex++;
    }
  }
}

class missionControlMessage
{
  String text;
  SoundFile audio;
  int frameToPlayAt;

  
  missionControlMessage(String _text, int _frameToPlayAt, SoundFile _audio)
  {
    text = _text;
    frameToPlayAt = _frameToPlayAt;
    if (_audio != null)
      audio = _audio;
  }
}
enum mouseAction
{
  RELEASED,
  PRESSED,
  SCROLL_UP,
  SCROLL_DOWN
}
class postProcessor
{
  int pixelSize;
  int spread;
  int spreadCompensation;
  int COLOR_0;
  int COLOR_1;
  int COLOR_2;
  int COLOR_3;
  
  public void render()
  {
    loadPixels();
    rectMode(CORNER);
    int hw = height*width;
    int yp = 0;
    int hop = (int)(height/(float)pixelSize);
    int wop = (int)(width/(float)pixelSize);
    for(int y = hop; y>-1; y--)
    {
      ++yp;
      int xp = 0;
      int yxw = y*width; //computing this multiplication only once y changes saves a few
      for(int x = wop; x>-1; x--)
      {
        ++xp;
        int col = pixels[x+yxw];
        int b = (int)(red(col)*0.2126f + green(col)*0.7152f + blue(col)*0.0722f); //faster and probably also more accurate than brightness()
        switch( (b + bayerThreshold4x(xp,yp)*spread - spreadCompensation)>>6 )
        {
          case -1: col = COLOR_0; break;
          case 0: col = COLOR_0; break;
          case 1: col = COLOR_1; break;
          case 2: col = COLOR_2; break;
          default: col = COLOR_3; break; 
          //the code allows brightness to 
          //be >1 due to the bayer pattern 
          //simply adding to the actual 
          //brightness. as such, having 
          //the brightest gradient color as
          //the default is mandatory
          
          //its also possible to go under
          //-1 but i am assuming were all 
          //gonna be responsible with our 
          //spreadcompensation selection.
          //we dont want the image to get 
          //too dark anyways
        }
        //if(bayerThreshold4x(xp,yp)*16<b)
        //col = #FFFFCCAA; else col = #FF003344;
        int xd = x*pixelSize;
        int yd = y*pixelSize;
        for(int px = 0; px<pixelSize; px++)
        for(int py = 0; py<pixelSize; py++)
        {
          int d = xd+px + (yd+py)*width;
          if(d<hw)
          pixels[d] = col;
        }
      }
    }
    updatePixels();
  }
  
  public int bayerThreshold2x(int xp, int yp)
  {
    switch((xp&1) + ((yp&1)<<1)) //p sure this is as effecient as it gets
    {
      default:return 0;
      //case 0:return 0;
      case 1:return 2;
      
      case 2:return 3;
      case 3:return 1;
    }
  }
  
  public int bayerThreshold4x(int xp, int yp)
  {
    switch((xp&3) + ((yp&3)<<2)) //p sure this is as effecient as it gets (again)
    {
      default:return 0;
      //case 0:return 0;
      case 1:return 8;
      case 2:return 2;
      case 3:return 10;
      
      case 4:return 12;
      case 5:return 4;
      case 6:return 14;
      case 7:return 6;
      
      case 8:return 3;
      case 9:return 11;
      case 10:return 1;
      case 11:return 9;
      
      case 12:return 15;
      case 13:return 7;
      case 14:return 13;
      case 15:return 5;
      //utterly incomprehensible thank you very much
      //its uh. called ordered dithering using threshold maps
      //wikipedia is your problem now
      //https://en.wikipedia.org/wiki/Ordered_dithering
      
      //is an array faster actually?
      //fml if so but im not gonna try
    }
  }
}
class pressureLever extends clickableObject
{
  
  int pressureValue;
  boolean on = false;
  float originalHeight;
  SoundFile leverOn;
  SoundFile leverOff;
  
  
  pressureLever(String _name, PVector _shape, PVector _position, int _pressureValue)
  {
    super(_name, _shape, _position);
    originalHeight = _position.y;
    pressureValue = _pressureValue;
    
    leverOn = new SoundFile(globals.game, "switch_on.wav");
    leverOff = new SoundFile(globals.game, "switch_off.wav");

    
  }
  
  public void onLeftClickReleased(PVector offset)
  {
    if(checkClickIntersection(offset))
    {
      on = !on;
      if (on)
      leverOn.play();
      else
      leverOff.play();
    }
  }
  
  public void render(PVector mousepos, PVector offset)
  {
    rectMode(CENTER);
    fill(255,133,0);
    if(!on)
    position.y = originalHeight;
    else
    position.y = originalHeight + 70;
    rect(position.x + offset.x,position.y + offset.y,shapeD.x,shapeD.y);
  }
  
  public void setOff()
  {
    on = false;
  }
}
class scene
{
  globalVariables globals;
  int leftScene;
  int rightScene;
  int thisScene;
  PVector startPosition;
  PVector position;
  boolean fullScreenScene;
 float soundVolume;
 
  scene(globalVariables globals, int leftScene, int rightScene, int thisScene, PVector position, boolean  fullScreenScene)
  {
    this.globals = globals;
    this.leftScene = leftScene;
    this.rightScene = rightScene;
    this.thisScene = thisScene;
    this.position = position;
    startPosition = position;
    this.fullScreenScene = fullScreenScene;
    soundVolume = 0;
  }
 
   public void onSwitchScene()
   {
     for (int i = 0; i < min(5,5 - ceil(((globals.oxygenCount -10)/ 10))); i++)
     {
       globals.ui.monsters.add(new Monster(new PVector(300, 300), i+1, requestImage("monster" + floor(random(1,6)) + ".png"), globals));
     }
   }
 
  public void updateScene(mouseAction action)
  {
  }
  
  public void renderScene()
  {
  }
  
  public void leftScene()
  {
  }
  
  public void rightScene()
  {
  }
}
class scrollBox extends clickableObject
{
  clickableObject scrollBar;
  
  scrollBox(String _name, PVector _size, PVector _position, float _scrollButtonSize, float _contentLength)
  {
    super(_name, _size, _position);
    contentLength = _contentLength;
    scrollButtonSize = _scrollButtonSize;
    scrollButtonSizeH = _scrollButtonSize*.5f;
    scrollButtonSizeRatio = _size.y/(_size.y+scrollButtonSizeH);
    
    scrollBar = new clickableObject("scrollbar"+_name, new PVector(16,_size.y), new PVector(_position.x+shape.x-8, _position.y));
  }

  float contentLength;
  float scrollButtonSize;
  float scrollButtonSizeH;
  float scrollButtonSizeRatio;
  
  float normScrollHeight;  
  float scrollHeight = 0;
  
  boolean mouseHoldingScrollBar = false;
  
  public void onScroll(float scroll, PVector mousepos)
  {
    if(!checkIntersection(mousepos, new PVector(0,0)))
    return;
    scrollHeight += scroll;
    scrollHeight = constrain(scrollHeight,0,contentLength);
    normScrollHeight = scrollHeight/contentLength;
  }
  
  public void onLeftClick(PVector mousepos)
  {
    if(!scrollBar.checkIntersection(mousepos, new PVector(0,0)))
    return;
    mouseHoldingScrollBar = true;
  }
  
  public void onLeftClickRelease()
  {
    mouseHoldingScrollBar = false;
  }
  
  public void rescaleContentLength(float contentSize)
  {
    contentLength = contentSize;
    normScrollHeight = scrollHeight/contentLength;
  }
  
  public void render(PVector mousepos, int COLOR_0, int COLOR_1, int COLOR_2, int COLOR_3)
  {
    if(mouseHoldingScrollBar)
    {
      normScrollHeight = (mousepos.y-scrollBar.position.y)/shapeD.y + .5f;
      normScrollHeight = constrain(normScrollHeight,0,1);
      scrollHeight = normScrollHeight*contentLength;
    }
    stroke(COLOR_0);
    rectMode(CENTER);
    fill(COLOR_1);
    rect(position.x,position.y,shapeD.x,shapeD.y);
    fill(mouseHoldingScrollBar ? COLOR_2 : COLOR_1);
    rect(position.x+shape.x-8,position.y,-16,shapeD.y);
    fill(mouseHoldingScrollBar ? COLOR_3 : COLOR_2);
    rect(position.x+shape.x-8,position.y+shapeD.y*(normScrollHeight-.5f)*scrollButtonSizeRatio,-16,scrollButtonSize);
  }
}


  public void settings() { size(1200, 900); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Deep_Dive" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
